<!---

This file is used to generate your project datasheet. Please fill in the information below and delete any unused
sections.

You can also include images in this folder and reference them in the markdown. Each image must be less than
512 kb in size, and the combined size of all images must be less than 1 MB.
-->
## Credits 
We gratefully acknowledge the Centre of Excellence (CoE) in Integrated Circuits and Systems (ICAS) and Department of Electronics and Communication (ECE) for providing the necessary resources and guidance. Special thanks to Dr. H V Ravish Aradhya (HOD-ECE), Dr. K S Geetha (Vice Principal) and Dr. K N Subramanya (Principal) for their constant support and encouragement to carry out this Tiny Tapeout SKY25a submission.

## How it works

Modern pipelined processors suffer from hazards, which are situations where the next instruction cannot execute correctly without stalling, forwarding, or flushing the pipeline. This project implements a Finite State Machine (FSM) to detect and resolve three classes of hazards:
  1.Control Hazards (Branches)
    o	Triggered when a branch instruction is in the pipeline.
    o	FSM moves to Con (Control Hazard) state.
    o	If the branch is resolved correctly (crct=1), the FSM returns to safe execution (Nor).
    o	If the branch is resolved wrongly (crct=0), the FSM enters Flush for one cycle, asserting do_flush=1 to clear wrong instructions.
  2.	Data Hazards (Read-After-Write conflicts)
    o	Detected when data=1.
    o	If forwarding (fwrd=1) is available, the FSM returns immediately to Nor (no stall).
    o	If forwarding is unavailable, FSM transitions to Dat and then to StaN (multi-cycle stall) until the data hazard clears.
  3.	Structural Hazards (Resource Conflicts)
    o	Occur when multiple instructions need the same hardware (e.g., ALU + memory).
    o	FSM moves to StaSin (single stall state).
    o	It holds the pipeline for one cycle or until the conflict clears.

  The FSM has six states:
    •	Nor → Normal execution, no hazard.
    •	Con → Control hazard handling (waiting on branch).
    •	StaSin → One-cycle stall (structural hazard or speculative branch stall).
    •	Flush → One-cycle flush after mispredict.
    •	Dat → Data hazard detected, forwarding decision pending.
    •	StaN → Multi-cycle stall for unresolved data hazard.
  Outputs generated by the FSM:
    •	pc_freeze → Freezes program counter when hazards are active.
    •	do_flush → Signals a flush cycle when a mispredicted branch is detected.
    •	resolved → Indicates hazard-free operation (1 in Nor).
  The reset is synchronous, active-low. On reset, FSM returns to Nor (safe state).

## How to test

You can verify the FSM behavior both in simulation and on hardware (TinyTapeout).
1. Simulation
  •	Run the provided testbench.	It applies various hazard scenarios: control hazards, mispredicts, data hazards with/without forwarding, structural hazards, and overlapping hazards. At every clock edge, the testbench prints:
  o	Input hazard flags (ctrl, data, str, branch, crct, fwrd)
  o	FSM outputs (pc_freeze, do_flush, resolved)
  o	FSM current state (state_out) for debugging.

->	Example test sequences:
  o	ctrl=1, branch=1, crct=1 → FSM handles control hazard and returns to Nor.
  o	ctrl=1, branch=1, crct=0 → FSM issues flush (do_flush=1).
  o	data=1, fwrd=1 → Data hazard detected but resolved via forwarding, no stall.
  o	data=1, fwrd=0 → FSM stalls (StaN) until data clears.
  o	str=1 → FSM performs single-cycle stall (StaSin).

Observe state transitions and control outputs.
2. Hardware (TinyTapeout/FPGA)
•	Map hazard inputs to ui_in bits (e.g., ui_in[0]=ctrl, ui_in[1]=data, etc.).
•	Map FSM outputs to uo_out bits (uo_out[0]=pc_freeze, uo_out[1]=do_flush, uo_out[2]=resolved, uo_out[5:3]=state_out).
•	Provide clock (clk) and reset (rst_n).
•	On TinyTapeout, you can toggle hazard inputs via the web interface or an external driver and watch outputs on LEDs/logic analyzer.
• Implement the same on FPGA by generating the bitstream and dumping the code onto the FPGA Board and manually give inputs to verify the outputs.

## External hardware

This project does not require any external hardware beyond the TinyTapeout digital harness.
Optional for demonstration:
•	LEDs → show FSM state or outputs in real time.
•	Logic analyzer → observe hazard flags and control signals.
•	FPGA board → emulate pipeline signals and drive the FSM before tapeout.

